// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
//✅ 作业 1：ERC20 代币
// 任务：参考 openzeppelin-contracts/contracts/token/ERC20/IERC20.sol实现一个简单的 ERC20 代币合约。要求：
// 合约包含以下标准 ERC20 功能：
// balanceOf：查询账户余额。
// transfer：转账。
// approve 和 transferFrom：授权和代扣转账。
// 使用 event 记录转账和授权操作。
// 提供 mint 函数，允许合约所有者增发代币。
// 提示：
// 使用 mapping 存储账户余额和授权信息。
// 使用 event 定义 Transfer 和 Approval 事件。
// 部署到sepolia 测试网，导入到自己的钱包

interface MYERC  {
    function balanceOf(address addr) external  view returns (uint);
    function transfer(address addr,uint amount) external returns (bool);
    function approve(address  spender,uint quota) external returns (bool);
    function transferFrom(address from,address to,uint amount) external returns (bool);
    function mint(uint amount) external returns (bool);
}
contract LoveToken is MYERC{
    string public  name;//代币名称
    address private adminAddr;//管理员地址
    uint public totalSupply;//确定初始总量
    mapping(address=>uint) public balances;//存储账户余额
    mapping (address=>mapping (address=>uint)) public allows;//授权映射

    event Transfers(address from,address to,uint amount);
    event Approval(address from,address to,uint quota);
    event Mint(uint amount);

    constructor(string memory _name,uint _totalSupply) {
        adminAddr=msg.sender;
        totalSupply=_totalSupply;
        name=_name;
        balances[adminAddr]=_totalSupply;//初始管理员地址为发行总量
    }
    modifier onlyAdmin() {
    require(msg.sender == adminAddr, "Not the owner!"); // 检查逻辑
    _; 
    }
    //查询余额
    function balanceOf(address addr) external  view returns (uint){
        return balances[addr];
    }
    //转账
    function transfer(address addr,uint amount) external returns (bool){
        require(balances[msg.sender]>amount,"Insufficient balance");//余额不足
        balances[msg.sender]-=amount;
        emit Transfers(msg.sender,addr,amount);
        return true;
    }
    //授权
    function approve(address  spender,uint quota) external returns (bool){
        require(allows[msg.sender][spender]+quota<=balances[msg.sender],"Insufficient authorization limit");//判断授权额度是否充足
        allows[msg.sender][spender]+=quota;
        emit Approval(msg.sender,spender,quota);
        return true;
    }
    //代扣转账
    function transferFrom(address from,address to,uint256 amount) external returns (bool){
        require(balances[from]>amount,"Insufficient balance");//余额是否充足
        require(allows[from][msg.sender]>amount,"Insufficient authorization limit");//授权额度是否充足
        balances[from]-=amount;
        balances[to]+=amount;
        allows[from][msg.sender]-=amount;
        emit Transfers(from, to, amount);
        return true;
    }
    //增发代币
    function mint(uint amount) external onlyAdmin returns (bool){
        emit  Mint(amount);
        balances[msg.sender]+=amount;
         return true;
    }
    
     
}