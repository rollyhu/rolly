// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0<0.9.0;
contract Hello {
 
    mapping (bytes1=>uint256)public lmMpa;

    struct RomanNumeral {
        uint256 value;
        string symbol;
    }

    RomanNumeral[] private romanNumerals;

    constructor (){
        lmMpa['I']=1;
        lmMpa['V']=5;
        lmMpa['X']=10;
        lmMpa['L']=50;
        lmMpa['C']=100;
        lmMpa['D']=500;
        lmMpa['M']=1000;

        // alMpa[1]='I';
        // alMpa[5]='V';
        // alMpa[10]='X';
        // alMpa[50]='L';
        // alMpa[100]='C';
        // alMpa[500]='D';
        // alMpa[1000]='M';
         // 初始化罗马数字映射（包含减法组合）
        romanNumerals.push(RomanNumeral(1000, "M"));
        romanNumerals.push(RomanNumeral(900, "CM"));
        romanNumerals.push(RomanNumeral(500, "D"));
        romanNumerals.push(RomanNumeral(400, "CD"));
        romanNumerals.push(RomanNumeral(100, "C"));
        romanNumerals.push(RomanNumeral(90, "XC"));
        romanNumerals.push(RomanNumeral(50, "L"));
        romanNumerals.push(RomanNumeral(40, "XL"));
        romanNumerals.push(RomanNumeral(10, "X"));
        romanNumerals.push(RomanNumeral(9, "IX"));
        romanNumerals.push(RomanNumeral(5, "V"));
        romanNumerals.push(RomanNumeral(4, "IV"));
        romanNumerals.push(RomanNumeral(1, "I"));
    }

    function getInt( string calldata str) public view  returns ( uint256){
        bytes memory bstr=bytes(str);
        uint256 len=bstr.length;
        int256 num=0;
        // string memory temp;
        for (uint i=0; i<len; i++) 
        { 
            bytes1 char=bstr[i]; 
            uint256 mapValue=lmMpa[char];    
            if((i<len-1)&&(mapValue<lmMpa[bstr[i+1]])){
                num=num-int256(mapValue);
            }else {
                num=num+int256(mapValue);
            }  
        }
        return uint256(num);
    }

    function intToRoman(uint256 num) public view returns (string memory) {
            require(num > 0 && num < 4000, "Number out of range (1-3999)");
            string memory result;
            
            for (uint256 i = 0; i < romanNumerals.length; i++) {
                while (num >= romanNumerals[i].value) {
                    result = string(abi.encodePacked(result, romanNumerals[i].symbol));
                    num -= romanNumerals[i].value;
                }
            }
            
            return result;
        }
 
}
